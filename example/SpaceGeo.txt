namespace spacegeo {
    concept SpaceGeo (description: "geometric = Cartesian space") : object::Object;
    concept Ray : object::Object;

    fun isLinear(space_: set::Set) -> boolean::Boolean {
        description { "is space_ a linear space?" }
    }

    fun scalar(space_: set::Set) -> object::Object {
      description {
        "scalar field of space_"
      }
      requires { isLinear(space_) }
    }

    fun dim(space_: set::Set) -> number::Natural {
      description {
        "dimension of space_"
      }
      requires { isLinear(space_) }
    }

    fun mulScalar(s: object::Object, v: object::Object, space_: set::Set) -> object::Object {
      description {
        "linear product of scalar p(1) and vector p(2) in space_"
      }
      //requires { set::hasElement(scalar(space_), s) }
      requires { set::hasElement(space_, v) }
      requires { isLinear(space_) }
    }

    fun isBasis(seq: seq::Seq, space_: set::Set) -> boolean::Boolean {
      description {
        "is p(1) a basis of space_"
      }
      requires { isLinear(space_) }
      requires { set::hasElement(space_, seq::item(seq)) }
    }

    fun vectorForLinComb(coords: seq::Seq, basis: seq::Seq, space_: set::Set) -> object::Object {
      description {
        "vector given by linear combination of sequence of coordinates p(1) and basis p(2) in space_"
      }
      requires { isLinear(space_) }
      //requires { set::hasElement(scalar(space_), seq::item(coords)) }
      requires { isBasis(basis, space_) }
    }

    fun vector(point: set::Set) -> matrix::Matrix {
      description {
        "vector from origin to p(1)"
      }
    }

    fun seqOfCoord(vector: object::Object, p2: seq::Seq, p3: set::Set) -> seq::Seq {
      description {
        "sequence of coordinates of vector p(1) with respect to basis p(2) in p(3)"
      }
    }

    fun isLinearTopological(space_: set::Set) -> boolean::Boolean {
      description {
        "is p(1) a linear topological space?"
      }
    }

    fun isMetric(space_: set::Set) -> boolean::Boolean {
      description {
        "is p(1) a metric space?"
      }
    }

    fun distance(p1: object::Object, p2: object::Object, space_: set::Set) -> number::Real {
      description {
        "distance of p(1) and p(2) in p(3)"
      }
      requires { set::hasElement(space_, p1) }
      requires { set::hasElement(space_, p2) }
      requires { isMetric(space_) }
    }

    fun isComplete(space_: set::Set) -> boolean::Boolean {
      description {
        "is p(1) a complete space?"
      }
    }

    fun isNormed(space_: set::Set) -> boolean::Boolean {
      description {
        "is p(1) a normed space?"
      }
    }

    fun norm(vector: object::Object, space_: set::Set) -> number::Real {
      description {
        "norm of p(1) in p(2)"
      }
      requires { set::hasElement(space_, vector) }
      requires { isNormed(space_) }
    }

    fun isBanachian(space_: set::Set) -> boolean::Boolean {
      description {
        "is p(1) a Banach space (normed and complete)?"
      }
    }

    fun isPreHilbertian(space_: set::Set) -> boolean::Boolean {
      description {
        "is p(1) a pre-Hilbert space (having an inner product)?"
      }
    }

    fun mulInner(v1: object::Object, v2: object::Object, space_: set::Set) -> object::Object {
      description {
        "inner product of p(1) and p(2) in p(3)"
      }
      requires { set::hasElement(space_, v1) }
      requires { set::hasElement(space_, v2) }
      requires { isPreHilbertian(space_) }
    }

    fun isOrthogonal(v1: object::Object, v2: object::Object, space_: set::Set) -> boolean::Boolean {
      description {
        "is p(1) orthogonal to p(2) in p(3)?"
      }
      requires { set::hasElement(space_, v1) }
      requires { set::hasElement(space_, v2) }
      requires { isPreHilbertian(space_) }
    }

    fun isHilbertian(space_: set::Set) -> boolean::Boolean {
      description {
        "is p(1) a Hilbert space (inner product and complete)?"
      }
    }

    fun isEuclidean(space_: set::Set) -> boolean::Boolean {
      description {
        "is p(1) a Euclidean space?"
      }
    }

    fun isCartesian(space_: set::Set) -> boolean::Boolean {
      description {
        "is p(1) a Cartesian space?"
      }
    }

    fun isPoly(poly: set::Set, space_: set::Set) -> boolean::Boolean {
      description {
        "is p(1) a polytope (boundary piecewise linear)?"
      }
    }

    fun isConvex(set: set::Set, space_: set::Set) -> boolean::Boolean {
      description {
        "is p(1) convex?"
      }
    }

    fun center(set: set::Set) -> object::Object {
      description {
        "point at which the barycenter of p(1) is located"
      }
    }
}
