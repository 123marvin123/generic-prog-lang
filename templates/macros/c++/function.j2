{% from "macros/c++/namespace.j2" import NamespaceChain with context %}
{% macro FunctionDefinition(def) %}
{% call NamespaceChain(def.ns) %}
{% set Name_ = def.name | title %}

struct Dec{{ Name_ }} {
    using ParamTupleOfConcept = ::cong::lang::core::Tuple<
    {%- for param in def.params -%}
        {%- if param.type == "placeholder_function_parameter" or param.type == "dependent_function_parameter" %}
{{ ConceptObject.ns | join('::') }}::Concept{{ ConceptObject.name }}
        {%- else %}
{{ param.concept.ns | join('::') }}::Concept{{ param.concept.name }}
        {%- endif %}{{', ' if loop.nextitem is defined }}
    {%- endfor -%}>;
    template<unsigned int Index_>
    struct Requirement
    {
        using Present = cong::lang::False;
        template<class...>
        struct Call
        {
            static constexpr cong::lang::True call(...);
        };
    };
};

struct Spec{{ Name_ }} {
    static constexpr auto name = "{{def.name}}";
    static constexpr auto description = "{{def.description}}";

    using ResultTupleOfExpReqEquiv = std::tuple<>;
};

{% for req in function_requirements(def.full_name) %}
/*
 * Requirement #{{ loop.index }}:
 * {{ req }}
*/
template<>
struct Dec{{ Name_ }}::Requirement<{{ loop.index0 }}> {
    using Present = cong::lang::True;
    template<
    {%- for i in range(def.params | length) -%}
class Arg{{ i + 1 }}_{{' , ' if not loop.last }}
    {%- endfor -%}>
    struct Call
    {
        static constexpr auto call({%- for p in def.params -%}Arg{{ loop.index }}_&& {{ p.name }}{{' , ' if not loop.last }}{% endfor -%})
        {
            using ExpType_ = decltype({{ req }});
            const auto& result = [&]{ return {{ req }}; };
            return cong::lang::intern::CondEval<
                        typename ::cong::lang::intern::IsExp::Call<ExpType_>::Type,
                        decltype(result),
                        ExpType_
                   >::call(result);
        }
    };
};{{' \n' if not loop.last }}{% endfor %} 

template <typename... Exp_>
using {{ Name_ }} = ::cong::lang::Bind< 
    ::cong::lang::intern::Environment,
    ::cong::lang::intern::Exp<::cong::lang::intern::FunctionImpl<Dec{{ Name_ }}, Spec{{ Name_ }}>>,
    Exp_...
>;

template <typename... Exp_>
constexpr
{{ Name_ }}<Exp_...> {{def.name}}(Exp_&&... args) 
{
    if constexpr (cong::lang::core::intern::is_constexpr_evaluable<cong::lang::intern::EvalRequirements, Dec{{ Name_ }}, Exp_...>::value) 
    {
        static_assert(
            cong::lang::intern::EvalRequirements::Call<Dec{{ Name_ }}, Exp_...>
                ::call(std::forward<Exp_>(args)...).native(),
            "Requirements not met at compile-time.");
    } else if(!cong::lang::intern::EvalRequirements::Call<Dec{{ Name_ }}, Exp_...>::call(std::forward<Exp_>(args)...).native()) 
    {
        throw std::runtime_error("Requirements not met at runtime.");
    }

    return ::cong::lang::bind(
        ::cong::lang::intern::Environment{},
        ::cong::lang::intern::Exp<::cong::lang::intern::FunctionImpl<Dec{{ Name_ }}, Spec{{ Name_ }}>>{},
        std::forward<Exp_>(args)...);
}
{% endcall %}
{% endmacro %}